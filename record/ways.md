# 技术方案
## 鉴权方案（session-cookie、Token验证、OAuth开放鉴权、HTTP Basic Authentication）
1. 单点登录：一次登录，就可以访问多个相互信任的系统（[单点登录（Single Sign On）看这一篇就够了](https://www.51cto.com/article/629264.html)）
2. toke无感刷新：登录的时候返回两个token，一个是短token、另一个是刷新token，短token过期了就用刷新token去换新的token。响应拦截器里面如果状态码是401那就要调刷新token的方法，刷完后再调用原来的请求，如果刷新token也过期了，这时候就要跳转到登录页面
## 大规模数据处理
1. 分页加载
2. 分两个变量来记录总数据和渲染数据，随着滚动动态计算渲染数据，例如Vue就有第三方库可以实现这效果vue-virtual-scroller
3. 使用webworker，将数据处理和渲染操作放到单独的线程
[面对大数据量渲染，前端工程师如何保证页面流畅性](https://blog.csdn.net/2401_84159839/article/details/138454844)
## 实时数据更新和通信

## 跨平台和设备兼容
1. [浏览器兼容](https://juejin.cn/search?query=%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98&fromSeo=0&fromHistory=0&fromSuggest=1&sort=1&enterFrom=home_page)
	- 其实浏览器的兼容就是css和js的兼容问题，一些旧的浏览器对css和js的新特性不支持。对于这种问题其实社区已经提供丰富的工具和方案来解决，主要策略就是将先进的语法转换为低版本浏览器兼容的形式。在这领域，postcss和babel是两个最常用的库，通常会结合一些编译打包工具来使用。其中postcss可以添加浏览器私有前缀和将先进的语法转为低版本浏览器支持的形式，babel则是将es6+的语法转为低版本浏览器支持的形式。还有一些就是添加reset.css文件，设置全局内边距和外边距为0
	- [前端开发中常见的浏览器兼容性问题及解决方案](https://juejin.cn/post/7366557738266132514?searchId=2024051615442482CE4020D3F99A22E62B)
2. 微信小程序
	- rpx转换问题

## 性能优化
- 懒加载
- 资源压缩
- 代码丑化
- 合并请求
- 使用缓存、使用cdn
- 移除不必要的插件和库

## 动态换肤
1. 采用属性选择器设置多套主题色变量
2. 需要切换主题色直接改变document的主题色属性
[前端最全的5种换肤方案总结](https://blog.csdn.net/KlausLily/article/details/136522469)
## 当页面出现比较慢的问题有可能是什么原因导致的，怎么解决
1. 可能原因
	- 网络请求过多，超出了并发限制；资源太大
	- 内存泄漏导致内存过大、过多使用全局变量、闭包等资源没有回收
	- 长时间占用js线程，script放到了页面的头部，有没有设置延迟加载或异步加载
	- dom节点或事件占用的内存过大

2. 解决方案
	- 减少http请求，图片使用雪碧图、使用缓存；进行资源压缩、代码拆分、按需加载
	- 尽量避免使用全局变量、注意闭包资源的回收
	- js采用延迟执行、异步加载等方式
	- 采用事件委托
[页面加载缓慢的因素](https://blog.csdn.net/weixin_42142447/article/details/137089027)
## 缓存的更新策略
静态资源基本不会变的用强缓存，有可能会变的用协商缓存，业务资源基本上存localstorage，localstorage维护了一个版本号，进入应用的时候会检查是不是最新的版本，不是的话会清空缓存然后让用户重新登录

## token失效无感刷新
返回401的时候去调刷新token的方法，然后将之前方法重新调一下，后面我考虑到一种问题，就是当多条数据并发请求的时候会多次调用刷新token的方法，带来了不必要的请求，然后我就弄了一个待执行数组，刷新token前先判断数组是否为空，为空才调刷新token的方法，把要执行的请求用箭头函数包了一下放到数组中，刷新完token后再去执行数组中的请求。后面考虑到增加待执行队列只是减少了token的请求次数，但原本并发的请求次数并没有减少，所以又让后端返回token的时候增加了个过期时间字段，前端把token和过期时间一起存起来，然后我们获取的token的时候就判断一下是否过期，过期了就不先请求先。
[微信小程序登录过期如何实现用户无感知重连](https://www.jianshu.com/p/25be00609ef5)

## 图片裁剪和分片
通过clip-path来进行裁剪
[一步步实现前端图片裁剪功能](https://blog.csdn.net/jimojianghu/article/details/127620196)
#  项目
## 粤医保
1. **登录流程**
	- 调wx.login获取用户登录凭证code
	- 后端拿用户登录凭证调微信的接口获取openId和UnionId，调接口除了需要传入code还要传appId和app密钥appsecret
	- 将openId和UnionId存入数据库，返回加密后openId和用openId加密生成5分钟时效的token
	- 用户点击跳转至粤信签进行登录，粤信签登录成功后调用navigationBackMiniProgram方法返回，我们小程序onShow的参数中能接受到授权码（authCode)
	- 再拿到这个授权码去后端调用粤信签的接口获取人员基本信息，并用openId绑定在数据库，然后将人员信息返回
	- 前端接受到这些信息存到localstorage中，再拿这些信息查询医保信息
	- token失效后拿加密的openId去后端获取新的token
2. **封装的组件**：
	- 办理须知： 根据业务类型查询该业务对应的须知信息（受理对象和办理须知），有个已阅读的勾选，5秒后方可点击确定
	- 公告栏：使用wx.createAnimation创建动画、createSelectorQuery()创建选择器示例获取内容区和文本的宽度，动画开始前将文本在x轴向右平移一个内容区宽度，然后将文本在x轴上向左平移一个文本宽度，过程中通过动画示例的export()导出动画数据给标签的animation属性，内容区要设置overflow:hidden，文本要设置white-space: nowrap
	- 材料上传：主要是采用wx.chooseImage接口来实现(最近看这接口停止维护了，新接口是wx.chooseMedia，时间太忙还没来得及看是否改用新接口)，返回值有一个本地临时路径，这个组件有设置设置了大小和类型的限制的话会给出提示并且重传，超过1M的图片会调用wx.compressImage()接口进行压缩，对调wx.getFileSystemManager().readFileSync()转base64
	- 模板预览组件：兼容url和base64格式，兼容图片和pdf，图片可以直接wx.previewImage，pdf的url需要先wx.downloadFile生成临时路径，然后再获取文件管理器存储图片wx.getFileSystemManager().saveFile，再根据存储的路径打开文档wx.openDocument；base64需要先转为arraryBuffer然后采用文件管理器先保存获取一个路径，然后判断如果是图片就直接wx.previewImage，其他类型的话wx.openDocument打开
	- 弹框组件、材料上传组件、下拉选项组件、区划组件
	- 跳转地图公共方法（wx.openLocation、如果后端有返回经纬度直接调用，没有的话调用腾讯地图api接口，根据地址查询经纬度）
3. **埋点实现**：
	- UV（当天访问网站的用户数），IP（当天访问网站的IP数），PV（当天访问页面的次数），VV（当天访问网站的次数）
	- 再app.js的onShow生命周期中会调一次VV的埋点方法，如果是当天首次进入会调用UV的埋点，首页的入口跳转我们是封装了一个跳转方法pageJump中，在这个方法里面会去调PV的埋点方法。基于wx.request封装了get、post请求，接口请求完后会调埋点的方法，失败的时候埋点数据会携带code、message等信息，动态配置了一个要请求埋点的url数组。
	- 埋点方法并不是直接请求，而是往缓存中插入数据，并启动一个定时器，2分钟后再发起埋点请求，在onHide的生命周期里看有没有埋点数据，如果有则发送请求并清除定时器
	- 埋点数据结构为`{type: 'UV', data: JSON.stringfy()}`，其中type有‘UV’、'PV’、'VV'、'SUCCESS'、'fail'
4. **消息订阅**：
	- 首先要在微信公众平台定义一个模板，每个模板有一个模板id，当用户办理完业务会有个确认弹框，点击确认我们就会调wx.getSetting获取用户的订阅配置，当有配置时说明之前授权过，就需要去判断是订阅开关没开，还是对应模板的开关没开，然后给个弹框提示指引用户去设置里面开启，当没有查到订阅配置时我们就调用wx.requestSubscribeMessage申请模板权限，入参是模板id集合，当用户授权后我们将openId、模板id、开通状态存到数据库表里去，当业务审核完后cmq会推送一条消息过来，我们消费的同时查数据库，如果是开通了消息订阅的，就调用微信的接口去发送消息，要带上token、模板id、模板参数、点击消息跳转的小程序页面路径
5. **xxl-job**：在网上下载到xxl-job的源码，然后根据教程建下表，修改下数据库配置，然后将项目部署到服务器上就行了，我们的业务项目加下xxl-job的依赖和配置类，然后我们就可以创建一个定时器执行任务的类(需要加上JobHandler注解设置任务名），然后在xxl-job的主界面创建执行器和执行任务
7. 分包：主包、查询、报销、异地、办理、广州、深圳
8. **项目的难点亮点或踩的坑**
	- 就有一次发布人员给我丢过来一张截图问我有没有遇到过这个问题吗，我看了下那个报错的意思就是资源文件超过了2M的最大限制，然后我就去看微信开发者工具自带的依赖分析，看了下发现也就是主包太大了，其他一些分包都没啥事，其中最大一块也就是静态资源文件夹，也就是图片那些嘛，占了有700多kb，第二大的是一个中山的定制化首页占500多kb，在之后首页的tab文件300多kb，还有就是一些封装的组件、api都分包占一两百kb ，然后我就微信官网、还有网上去看，主要的建议是说进行分包、还有把图片那些资源上传到服务器、删掉一些无用的代码和开启样式文件脚本文件的压缩等，我们这个我主要看了也就是将图片放到服务器和把中山那个定制化主页单独分个包会比较合适，还有一些说开始样式文件脚本文件压缩的我们也早就开启了，然后我就去跟我们组长去说这个事，他也看了下后面就说可以按照我说的那样去搞，然后录个缺陷跟进下就好了，后面我就主要是弄了分包然后把那些图片给到UI他给弄成了雪碧图，然后我又去把那些用到图片的地方改了，最后整体弄下来后就由原来的2M变为了700多kb，然后又跟leader商量下做一个规范的宣贯，图片资源要放到服务器上，要注意包的大小，不要把一些可以分包的页面放到了主包里
	- 多文件上传，报销类业务可能会传很多证明材料，这些材料需要先暂存到我们后端的obs，然后再提交业务数据到核心系统生成一个业务流水号，再根据业务流水号去传材料到核心系统，在这过程中处理时间过长一方面可能会请求超时，一方面让用户一直在等待也不好。所以我们就开会讨论采取异步的方式进行处理。先暂存到我们公服的系统，直接给用户提示提交成功了让他稍后在办事进度里面去查看，然后通过xxl-job定时器去定时调用核心
	- 之前弄过一个气泡框提示组件，就是有一个问号图标，点击后会有一个弹框显示一些注释信息，那个弹框是有一个框和一个三角箭头，[有的设备会显示一段间距](https://juejin.cn/post/7257516901843763257?searchId=202404102023571DB84622F2404CB3FFC2)，有的不会
	- wxss中url()无法使用本地资源图片，设置background-image时候报错，可使用网络图片、base64图片或者在wxml中的内联样式中使用，在wxml中内联样式中使用模拟器可以展示，但在真机中不能显示，对此可在wxss中使用base64方式(网上有在线将图片转换成base64的工具)
	- 跳转页面传输参数的时候注意数据有没有特殊符号，有的话需要用encodeURIComponent转换一下，如果数据中出现&可能会导致内容被隔断
	- wx.request() 返回的状态码 res.statusCode 的值在 iOS 下是 int 型数据，而在 Android 6.0.1 上却是 String 型数据。更规范的方法是使用parseInt(res.statusCode) === 200 来实现
	- 兼容性问题
	- 信息安全问题
	- 首页区划选择框
## 终端服务
1. 搭建、部署
	- 搭建：`vue create 项目名`创建项目（vue-cli版本要4.5.0以上才能创建vue3），采用手动选择特性，选了babel、ts、router、vuex、eslint，后面还加了axios、nutui、moment、scss
	- 部署：将打包后的dist文件放到服务器的tomcat上，外网通过里约网关调到服务器的nginx里，然后再转发到前端页面
	- 组件：选择器组件、弹框组件、机构选择组件、空白组件（组件封装要考虑复用性、也要一定的灵活度，通过props和插槽实现一些特殊化的东西）
2. 功能开发：
	- 我们就只是终端机里面的一个h5页面，它跳转到我们页面的时候会传证据号码过来，终端机那边通过扫描身份证或者输入获取参保人的证据信息
	- 查询功能（医院、药店、经办机构、参保、享受待遇、药品信息、缴费、就医记录、备案信息、医用耗材、疾病与诊断目录）办理功能（门诊选点、门慢门特、异地备案、亲情账户绑定、城乡居民参保登记/变更、新生儿参保登记）
3. 响应式
	- 媒体查询 + vw。使用`@media (orientation: portrait )`设置竖屏样式，`@media (orientation: landscape )`设置横批样式。采用postcss-px-to-viewport将px转为vw，默认竖屏，有参数可以转化为横屏。UI原型稿尺寸为1280*800。
	- 横屏时搜索框和一些下拉选项都是在同一行，查询结果还有一些输入条件都是两条一行，竖屏时搜索框单独一行，各种下拉选项都在同一行，查询结果和输入条件都是一行一条
	- [不同Vue脚手架中postcss-px-to-viewport设置](https://blog.csdn.net/qq_39467560/article/details/130624243)  
	- [Vue3中postcss-px-to-view自适应](https://blog.csdn.net/weixin_45532665/article/details/134187391)
4. 封装文件上传组件
入参：业务类型、区划、uuid
内部逻辑：使用watch监听传入的属性都不为空调用获取二维码base64的方法，该方法会将我们上传材料功能页的路径和业务类型、区划传入后端生成二维码图片，返回的base64图片设置到img中，并开启一个3秒的定时器去校验二维码是否失效，失效有刷新的方法。用户在上传材料页面提交完材料后可以在终端的业务页面上点击下一步然后通过uuid查询到上传的材料。后端采用MultiFormatWriter工具类去生成的二维码。
5. **亮点难点**
	- 多屏幕适配
	- 高还原要求
## 国家app
1. uniapp打包升级方案
	- 整包升级：发布打包apk，放到OSS，用户打开app时候获取设备版本号(plus.runtime.appid、plus.runtime.versionCode、versionName),校验版本号是否最新，是的话给予用户提示然后plus.runtime.openURL(url)打开第三方应用下载apk进行安装。一般版本名不一致采用整包更新，版本号不一致采用热更新。
	- 热更新：打包wgt包放到OSS，用户打开app时候获取设备版本号(plus.runtime.appid、plus.runtime.versionCode、versionName),校验版本号是否最新，是的话uni.downloadFile下载wgt然后plus.runtime.install(tempFilePath, {force: true // 强制更新 }, res => {},err => {})进行安装。其实整包也可以这样安装。
2. 药价通要跳转地图
	- 总体来说就是判断当前设备是否存在一些地图应用（百度、腾讯、高德），如果有底部就给出一个选项弹出层，点击根据这个应用的路径跳转到具体的地图应用。主要使用的是uni-app基于html5+标准引擎暴露出来的plus对象，这个对象会有一些调用设备的能力。
	- 需要先调用`uni.getSystemInfoSync().platform`获取当前设备时Android还是iOS，然后调用`plus.runtime.isApplicationExist`方法判断百度、腾讯、高德等地图应用有没有安装，没有安装则弹框提示用户安装地图应用，安装了使用`plus.nativeUI.actionShee{ttitle: "选择" + tip, cancel: "取消", buttons: buttons}`弹个选择面板给用户选择要跳转的地图应用，用户选择后通过`plus.runtime.openURL()`方法打开指定的地图应用。各个地图的跳转url其实都是各自固定的（Android和iOS各不同），我们只需要将规定的经纬度字段拼接上去就好了
3. 权限校验
4. ios无法预览图片
5. 接入其他H5页面
6. 地图导航
7. 踩坑
	- 开发文件上传组件的时候用到了uni.uploadFile方法，出现了安卓能正常，ios上传失败的情况，uploadFile的参数里一定要加上`header`，但是如果header里面加了`'content-type' : 'multipart/form-data`，后台会报`uploadFile:fail undefined`，如果需要formData携带额外的参数，里面一定不能有file参数
8. **难点亮点**
	- 开发了一个医保药品查询的功能，可以查询到附近的药店药品价格等信息，在其中需要实现导航功能，但是uni-app的openLocation方法只能打开一个简略的地图，没有导航功能，后面是采用调用原生接口获取当前手机安装的地图软件，然后弹出一个选择框让用户进行选择对应的地图进行跳转，可以使用plus.runtime.openURL传入url进行跳转，url需要拼接上经纬度那些
## 粤省事
之前是向粤省事团队申请了一个原生小程序的分包，我们之前在分包开发，后面随着功能的增多，分包大小有限制，而且发版流程也很复杂（申请合作伙伴平台的权限，申请开通vpn，申请开发者权限，代码提交要eslint检查、合包检查，写测试文档，写发版申请），所以改为了h5接入的方式，由技术大佬确定了Taro框架
1. 培训
介绍文件目录、新增功能要改什么、一些公共方法的介绍、埋点的介绍
2. 封裝的组件：选择器组件

## 网厅
1. 权限校验
	- beforeEach中判断跳转的路径是否需要登录，需要登录但又没有登录给一个确认框提示，两个按钮，一个跳转至登录页，一个停留在当前页，登录了还要判断跳转的是否是需要进行实名认证的页面（投诉举报、信访大厅），如果没实名认证则给一个确认框提示
2. 动态路由
	- 网厅的页面分为通用页面（登录注册、重置密码、实名认证、意见反馈、个人中心等跟实际医保业务无关的）和动态路由页面（由每个地市开通的功能决定，登录时根据个人参保地市去查询）。动态路由界面由数据库查询得到，登录成功或者实名认证成功回去更新路由，通过addRoutes添加动态路由，动态路由对象需要进行component的处理 () => import(\`@/view/${viewPath}\`)，如果在beforeEach中添加动态路由需要这样进行设置进行跳转`next({ ...to, replace: true })`，如果直接next()会一直白屏（一开始就是在beforeEach设置的）
3. 登录
	- 验证码登录：封装了一个校验码组件，里面调后端接口会返回一个base64和uid，将uid返回出来跟账号数据一起提交，提交完后会返回一个accessToken和refreshToken，accessToken会设置到cookie上，然后跳转至首页
	- 扫码登录：调接口获取二维码的base64跟uid，将二维码渲染出来，开启一个5秒的定时任务根据uid去查询状态(未授权、授权成功还是二维码失效），当二维码失效的时候给一个二维码失效然后点击刷新的展示效果，授权成功后接口可以获取到accessToken和refreshToken，存进cookie然后跳转至首页。二维码失效、授权成功、切换为验证码登录的时候需要清除定时器
## 深圳医保平台
1. 通用页面生成器
组长弄了一个excel表格，这个表格能生成json，将json输入到页面上，能生成一个大概的预览图（循环json判断组件类型渲染对应的组件），点击生成的时候使用ref获取预览组件的vnode，然后将标签、属性等拼接起来形成一个字符串，传到后端接口返回文本流
2. 实现电子签章
	- 封装了一个签章组件，可以通过ref调组件show方法并将pdf的base64传进去，然后展示一个弹框，首次打开会提示"电子签章服务未开启"，有一个点击启动电子签章服务的按钮
	- 点击按钮会创建跟本地电子签章服务和CA证书助手的websocket连接，会设置onopen、onerror、onmessage、onclose等方法，还设置一个超时定时器方法，超时还没连接成功就主动关闭（调websocket的close方法），中途启动成功或者失败给予提示。
	- 签章首先需要获取到插入ukey的证书信息，在进行签章，这个签章组件是经历过了两个方案的迭代
	- 方案1是用iframe嵌入电子签章客户端的页面并将pdf的base64数据传进去，签章好后再通过iframe去获取签章后的base64，在其中通过postMessage和window.onmessage进行通信。
	- 方案2是由于后面医保局要求要固定签名域，也就是在指定的位置签名，我们实现是先通过websocket获取到ukey的证书信息和电子签章服务的签章图片base64，然后调后端接口去进行服务端代理签名（后端通过关键字去匹配签章位置，可以设置关键字和偏移量），然后再返回一个签章好的base64通过iframe展示出来，点击下载通过window.open打开新页面下载。
	
	**补充：**

	- 本地要下载的软件BJCA证书助手、PDF电子签章客户端
	- Ukey即usb key，就跟一个u盘一样，里面存储了用户的私钥和数字证书，我们要能识别的CA证书有广东CA、深圳CA、北京CA、网证通，北京CA跟其他CA公司一起整合为一个证书助手安装包
	- websocket每次发送请求必须的两个参数：方法名，uuid（服务类型_组件created的时间戳_递增index），uuid为了让客户端知道调哪个方法，uuid为了在onmessage识别是那一次请求的响应，发送消息时通过uuid将回调方法记录起来，接受消息时能获取到uuid参数，然后调对应回调
	- websocket心跳检测：客户端定时去调服务端，服务端给予响应证明服务端还活着，服务端也定时调客户端。事件间隔15秒，如果没有响应或者触发了onclose事件那就要重连，重连之间的时间间隔需要指数增加

4. 亮点难点
	- 用了vue-pdf进行pdf的预览和打印，出现了中文乱码的问题，后面去看官方文档也没有提到有这个问题，然后就去看源码，发现是源码里的问题，然后我就去改了源码，改了代码我们需要同步给别人并且我们打包是用jenkins打包的，所以我安装了一个patch-package的依赖，然后执行npx patch-package命令就能对我们修改的内容在根目录生成一个补丁包，然后我们在package.json的script脚本中增加一个postinstall: patch-package（postinstall是npm的一个钩子，会在依赖安装完后去执行对应的脚本）
	- 封装了电子签章组件，实现了使用Ukey去给pdf进行签章，其实简单来说就是获取到ukey里面的证书信息，然后传到电子签章客户端页面去进行签章，签章好后获取到签章完的pdf信息保存起来。其中比较麻烦就是我们项目跟其他应用之间的通信，签章的一个交互流程是怎么样的，这在当时是比较蒙的，对这些基本上都没什么了解，我甚至连Ukey、CA这些事什么都不清楚，我知道线下盖章那些拿印印一下就好了，但是这种线上的要怎么给它印出来，这些都不清楚，当时我白天我去跟CA公司跟电子签章客户端的人去了解流程那些，晚上又自己回去查资料，也是边了解边去搞，也搞了挺久的，大概弄了一个多月。
	- 文件上传、大文件上传、断点续传
	- excel、pdf、word预览、导入、导出、在线excel
	- 二次开发富文本编辑框
	- 工程化相关，修改代码规范配置eslint，可视化mock，打包优化（webpack改vite），git提交自动eslint检查，githook自动推送到集成服务
	- 性能优化：首屏加载优化(异步引入延后加载、利用构建压缩、tree-shaking、gzip、替换一些库，老版本替换新版本，减少第三方库）、大数据量渲染优化（一次渲染一部分）、体验优化（骨架屏、兜底图片、操作反馈）、组件可扩展性和易用性、优化接口出错处理，并发处理

## 智慧殡葬项目
1. rfid硬件设备对接
- 通过sdk先对要监听的按键key注册，然后再设置监听事件，当物理按键按下后就能在监听事件接受到对应的key并进行不同的操作

# 技术字典
## 微前端
[微前端了解](https://editor.csdn.net/md/?articleId=124238558)
[微前端（无界）](https://juejin.cn/post/7212603829572911159?searchId=20240408225204862CEEA88CDA1594A12E)
[微前端框架 之 qiankun](https://blog.csdn.net/fmk1023/article/details/114276311)
[qiankun官网](https://qiankun.umijs.org/zh)
## 低代码
1. 要给组件元素设置可拖拽，监听一些拖拽事件来计算放置的坐标，整个画布是一个相对布局，组件绝对布局
2. 利用组件在数组中的下标作为z-index值来控制层级
3. 业界产品
	- 阿里宜搭：可以创建不同的应用，通过简单的拖拉拽就能配置不同的页面，配置好后就能发布展示，其中分为表单界面、流程界面、报表页面、展示页面四种页面
	- 百度爱速搭
	- 腾讯微搭
	- 网易轻舟
	- 白码
4. 自己实现一个
	- 左边物料区以两排形式存着组件，每一个组件都是一个长方形，左边显示组件名，右边一个加号；中间展示区中组件左边是中文值，右边是组件类型
	- 有容器组件和基础组件，先添加容器组件，容器组件可以配置每行展示的列数，基础组件有输入框组件，下拉框框组件，按钮组件，table组件
	- 选中容器组件后可以点击左边物料区中组件，点击加号后即会添加到容器对象children中，每个组件可以配置中文名、字段名、是否必填、placeholder，容器组件分为三种类型，search、submit、show，查询和提交底部都会有两个按钮，查询（提交）和清除，按钮的事件中默认写好了一些逻辑，可以对其进行修改，逻辑是通过eval进行调用的，接口也是容器组件配置的，查询后会将返回数据放到output字段，提交会添加一些提交成功的提示。
	- 最底下有预览和保存两个按钮
	- 有一个渲染组件，专门将页面渲染出来，点击预览会展示一个弹框，将对象数据传入渲染组件，遍历children用component is将组件渲染出来，保存则会将弹出一个页面信息配置页面，配置菜单位置信息，每一个页面的路径都是公共渲染页面路径拼接是页面id，渲染的时候根据页面id获取json信息
[低代码平台](https://editor.csdn.net/md/?articleId=124203443)
[demo项目](https://github.com/woai3c/Front-end-articles/issues/19)
[国内低代码开发平台排名](https://blog.csdn.net/m0_60546144/article/details/135486444)

## 快应用
跟小程序差不多，无需下载，可以直接在桌面访问和搜索，与小程序的区别就是无需依赖任何软件应用，比如微信小程序是需要依赖于微信app的

## 云开发
是后端的一种开发服务，云开发平台提供了一整套的开发环境和工具平台。云开发基于serverless架构，开发者无需去管理基础的架构，如服务器和数据库，只需要去关注业务逻辑的开发
## 可视化
1. [G2](https://g2.antv.antgroup.com/manual/introduction/what-is-g2)：js编写，用于制造网页可视化
2. [echarts](https://echarts.apache.org/zh/index.html)：基于js的可视化图标库 

## Terser（JS代码压缩工具）
Terser源自UglifyJS，是一个现代化的代码压缩器，专注于JavaScript ES6+语法的支持和性能优化。它的主要功能是将源代码转换为更小的字节，通过删除未使用的变量、函数以及简化表达式等方式实现，同时保持代码的功能不变。
[探索Terser：JavaScript代码压缩的艺术](https://blog.csdn.net/gitblog_00082/article/details/136865083)
## loash

## nuxt
基于Vue，用于创建服务端渲染项目的轻量级框架

## 行为收集
逐帧收集，收集的时候增量收集，只收集变化的部分
[一种基于 “领域模型” 的建站模式](https://cloud.tencent.com/developer/article/1949055)

## Monaco Editor
浏览器端的vscode编辑器
[Monaco Editor](https://blog.csdn.net/weixin_45855469/article/details/136456755)
## Weex
用web语言来开发原生应用的框架，它不依赖于特定框架，但Vue和Rax（渐进式的React框架，用于构建多端应用）有完善的支持

## tailwindcss
是一个原子化css框架，可以用来创建很多原子化样式的类名供我们在项目中直接使用。它的工作原理是扫描所有 HTML 文件、JavaScript 组件以及任何 模板中的 CSS 类（class）名，然后生成相应的样式代码并写入 到一个静态 CSS 文件中
1. 优点
- 传统的css随着功能和页面的增加css也会增加，tailwindcss预先定义原子类，后面功能的增加只需要组合不同的原子类即可，编译出来的css增量几乎为0
[Tailwind CSS](https://blog.csdn.net/xinyebudaoshi/article/details/135061079)
[官方文档](https://www.tailwindcss.cn/docs/installation)

# 工具积累
## vscode
1. 快捷键
	- ctrl + h：查找替换
	- ctrl + k后按p：复制当前打开文件的路径
	- ctrl + `：打开终端
2. 好用的插件
	- 需要安装的git插件：git graph
# 跳转
## [前端三板斧（html、css、javascript）](https://blog.csdn.net/qq_43565396/article/details/139072665)
## [Vue问题积累](https://blog.csdn.net/qq_43565396/article/details/139072743)
## [React问题积累](https://blog.csdn.net/qq_43565396/article/details/139072810)
## [常用框架问题积累（原生微信小程序、uni-app、taro）](https://blog.csdn.net/qq_43565396/article/details/139072869)
## [工程化问题积累](https://blog.csdn.net/qq_43565396/article/details/139072905)
## [网络、设计模式、算法、后端问题积累](https://blog.csdn.net/qq_43565396/article/details/139072981)
## [面试相关积累](https://blog.csdn.net/qq_43565396/article/details/130794769)